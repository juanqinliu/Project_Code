#!/bin/bash

# Global Detection PT Model to TensorRT Engine Export Script (One-Step) - C++ Version
# Usage: ./export.sh [options]

set -e  # Exit on error

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
EXPORT_ONNX_SCRIPT="$SCRIPT_DIR/export_onnx/export_onnx.sh"
EXPORT_ENGINE_SCRIPT="$SCRIPT_DIR/export_engine/export_engine.sh"

# Print colored messages
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_step() {
    echo -e "${PURPLE}[STEP]${NC} $1"
}

print_separator() {
    echo -e "${CYAN}========================================${NC}"
}

# Show help information
show_help() {
    echo "Global Detection PT Model to TensorRT Engine Export Script (One-Step) - C++ Version"
    echo ""
    echo "This script combines PT->ONNX->Engine conversion into a single command using C++ implementation."
    echo ""
    echo "Usage:"
    echo "  $0 -i <model_path> [options]"
    echo ""
    echo "Required Options:"
    echo "  -i, --input PATH      Input PT model file path"
    echo ""
    echo "Output Configuration:"
    echo "  -o, --output PATH     Output Engine file path (auto-generated by default)"
    echo "  --onnx-output PATH    Intermediate ONNX file path (auto-generated by default)"
    echo "  --keep-onnx           Keep intermediate ONNX file after conversion (default: true)"
    echo ""
    echo "ONNX Export Options:"
    echo "  -s, --static          Generate static ONNX model (recommended for TensorRT)"
    echo "  -d, --dynamic         Generate dynamic ONNX model"
    echo "  --imgsz SIZE          Input image size (default: 640)"
    echo "  -b, --batch-size SIZE Batch size (default: 1)"
    echo "  --opset VERSION       ONNX opset version (default: 12)"
    echo "  --simplify            Simplify ONNX model (default: enabled)"
    echo "  --no-simplify         Do not simplify ONNX model"
    echo "  --device DEVICE       Device to use for ONNX export (default: 0)"
    echo ""
    echo "TensorRT Engine Options:"
    echo "  --precision TYPE      Precision type (fp32/fp16/int8, default: fp32)"
    echo "  --workspace SIZE      Workspace size in GB (default: 2.0)"
    echo ""
    echo "INT8 Calibration Configuration:"
    echo "  --calib-list PATH     Path to the calibration image list file"
    echo "  --calib-dir PATH      Path to the calibration image directory"
    echo "  --calib-num NUM       Maximum number of calibration images (default: 50)"
    echo "  --calib-cache PATH    Path for the calibration cache file"
    echo ""
    echo "C++ Build Options:"
    echo "  --build               Build C++ project before conversion"
    echo "  --clean               Clean build directory"
    echo "  --rebuild             Rebuild C++ project"
    echo ""
    echo "Other Options:"
    echo "  -h, --help            Show this help message"
    echo "  --verbose             Enable verbose output"
    echo "  --onnx-only           Only convert PT to ONNX (skip Engine conversion)"
    echo "  --check-env           Check environment dependencies"
    echo ""
    echo "Examples:"
    echo "  # Basic conversion (FP32)"
    echo "  $0 -i weights/global_fixed_best_train63.pt"
    echo ""
    echo "  # FP16 precision conversion"
    echo "  $0 -i weights/global_fixed_best_train63.pt --precision fp16"
    echo ""
    echo "  # INT8 precision conversion with calibration"
    echo "  $0 -i weights/global_fixed_best_train63.pt --precision int8 --calib-dir export_engine/calib_data/"
    echo ""
    echo "  # Build and convert"
    echo "  $0 -i weights/model.pt --build --precision fp16"
    echo ""
    echo "  # Only export to ONNX"
    echo "  $0 -i weights/model.pt --onnx-only"
    echo ""
}

# Check environment dependencies
check_environment() {
    print_step "Checking environment dependencies..."
    
    local missing_deps=()
    
    # Check for Python
    if ! command -v python3 &> /dev/null; then
        missing_deps+=("python3")
    else
        local python_version=$(python3 --version 2>&1 | awk '{print $2}')
        print_success "Python version: $python_version"
    fi
    
    # Check for required scripts
    if [ ! -f "$EXPORT_ONNX_SCRIPT" ]; then
        print_error "ONNX export script not found: $EXPORT_ONNX_SCRIPT"
        return 1
    fi
    
    if [ ! -f "$EXPORT_ENGINE_SCRIPT" ]; then
        print_error "Engine export script not found: $EXPORT_ENGINE_SCRIPT"
        return 1
    fi
    
    # Check Python dependencies
    print_info "Checking Python dependencies..."
    
    local python_deps=("torch" "onnx" "ultralytics")
    for dep in "${python_deps[@]}"; do
        if ! python3 -c "import ${dep//-/_}" &> /dev/null; then
            missing_deps+=("python3-$dep")
            print_warning "✗ $dep (not installed)"
        else
            print_success "✓ $dep"
        fi
    done
    
    # Check C++ build dependencies
    print_info "Checking C++ build dependencies..."
    
    if ! command -v cmake &> /dev/null; then
        missing_deps+=("cmake")
        print_warning "✗ cmake (not installed)"
    else
        print_success "✓ cmake"
    fi
    
    if ! command -v make &> /dev/null; then
        missing_deps+=("make")
        print_warning "✗ make (not installed)"
    else
        print_success "✓ make"
    fi
    
    if ! command -v g++ &> /dev/null; then
        missing_deps+=("g++")
        print_warning "✗ g++ (not installed)"
    else
        print_success "✓ g++"
    fi
    
    # Check for CUDA
    if command -v nvcc &> /dev/null; then
        local cuda_version=$(nvcc --version | grep "release" | awk '{print $6}' | cut -c2-)
        print_success "CUDA version: $cuda_version"
    else
        print_warning "CUDA (nvcc) not found"
    fi
    
    # Check for GPU
    if command -v nvidia-smi &> /dev/null; then
        local gpu_count=$(nvidia-smi -L | wc -l)
        print_success "Found $gpu_count GPU(s)"
        if [ "$gpu_count" -gt 0 ]; then
            nvidia-smi --query-gpu=name,memory.total --format=csv,noheader,nounits | while read line; do
                print_info "  GPU: $line MB"
            done
        fi
    else
        print_warning "nvidia-smi not found"
    fi
    
    # Check for TensorRT
    if [ -z "$TENSORRT_HOME" ]; then
        print_warning "TENSORRT_HOME not set, will auto-search TensorRT"
    else
        print_success "TensorRT path: $TENSORRT_HOME"
    fi
    
    # Check for OpenCV
    if ! pkg-config --exists opencv4 && ! pkg-config --exists opencv; then
        print_warning "OpenCV pkg-config not found, please ensure OpenCV is properly installed"
    else
        local opencv_version=$(pkg-config --modversion opencv4 2>/dev/null || pkg-config --modversion opencv 2>/dev/null)
        print_success "OpenCV version: $opencv_version"
    fi
    
    # Report missing dependencies
    if [ ${#missing_deps[@]} -gt 0 ]; then
        print_error "Missing the following dependencies:"
        for dep in "${missing_deps[@]}"; do
            echo "  - $dep"
        done
        print_info "Installation suggestions:"
        echo "  pip3 install torch onnx ultralytics"
        echo "  sudo apt-get install cmake make g++"
        echo "  # Install CUDA, TensorRT, and OpenCV as needed"
        return 1
    fi
    
    print_success "Environment check passed"
    return 0
}

# Validate PT model file
validate_pt_file() {
    local pt_file="$1"
    
    if [ ! -f "$pt_file" ]; then
        print_error "PT model file does not exist: $pt_file"
        return 1
    fi
    
    if [[ ! "$pt_file" =~ \.(pt|pth)$ ]]; then
        print_error "Unsupported file format, requires .pt or .pth files"
        return 1
    fi
    
    # Check file size
    local file_size=$(stat -c%s "$pt_file" 2>/dev/null || stat -f%z "$pt_file" 2>/dev/null || echo "0")
    if [ "$file_size" -lt 1024 ]; then
        print_warning "PT file is too small ($file_size bytes), may not be a valid model file"
    fi
    
    print_success "PT model file validation passed: $pt_file"
    return 0
}

# Step 1: Convert PT to ONNX
convert_pt_to_onnx() {
    local pt_file="$1"
    local onnx_file="$2"
    shift 2
    local onnx_args=("$@")
    
    print_separator
    print_step "Step 1/2: Converting PT model to ONNX format"
    print_separator
    
    print_info "Input file: $pt_file"
    print_info "Output file: $onnx_file"
    
    # Build command for ONNX export
    local cmd=("$EXPORT_ONNX_SCRIPT" "-i" "$pt_file" "-o" "$onnx_file")
    cmd+=("${onnx_args[@]}")
    
    print_info "Executing command: ${cmd[*]}"
    
    if "${cmd[@]}"; then
        print_success "ONNX conversion completed: $onnx_file"
        return 0
    else
        print_error "ONNX conversion failed!"
        return 1
    fi
}

# Step 2: Convert ONNX to Engine
convert_onnx_to_engine() {
    local onnx_file="$1"
    local engine_file="$2"
    shift 2
    local engine_args=("$@")
    
    print_separator
    print_step "Step 2/2: Converting ONNX model to TensorRT Engine format"
    print_separator
    
    print_info "Input file: $onnx_file"
    print_info "Output file: $engine_file"
    
    # Change to export_engine directory to ensure correct working directory
    local original_dir="$(pwd)"
    local engine_dir="$(dirname "$EXPORT_ENGINE_SCRIPT")"
    
    print_info "Changing to engine directory: $engine_dir"
    cd "$engine_dir"
    
    # Convert ONNX file to absolute path if it's relative
    local abs_onnx_file="$onnx_file"
    if [[ ! "$onnx_file" = /* ]]; then
        # If it's a relative path, make it relative to the original directory
        abs_onnx_file="$(cd "$original_dir" && pwd)/$onnx_file"
    fi
    
    # Convert engine file to absolute path if it's relative
    local abs_engine_file="$engine_file"
    if [[ ! "$engine_file" = /* ]]; then
        # If it's a relative path, make it relative to the original directory
        abs_engine_file="$(cd "$original_dir" && pwd)/$engine_file"
    fi
    
    print_info "Using absolute ONNX path: $abs_onnx_file"
    print_info "Using absolute engine path: $abs_engine_file"
    
    # Build command for Engine export
    local cmd=("$EXPORT_ENGINE_SCRIPT" "-i" "$abs_onnx_file")
    
    if [ -n "$engine_file" ]; then
        cmd+=("-o" "$abs_engine_file")
    fi
    
    # Convert engine arguments to C++ format
    local converted_args=()
    local i=0
    while [ $i -lt ${#engine_args[@]} ]; do
        case "${engine_args[$i]}" in
            --precision)
                converted_args+=("-p" "${engine_args[$((i+1))]}")
                i=$((i+1))
                ;;
            --workspace)
                converted_args+=("--workspace-size" "${engine_args[$((i+1))]}")
                i=$((i+1))
                ;;
            --calib-dir)
                # Convert calibration directory path to be relative to export_engine directory
                local calib_dir="${engine_args[$((i+1))]}"
                if [[ "$calib_dir" = export_engine/* ]]; then
                    # Remove export_engine/ prefix since we're already in export_engine directory
                    calib_dir="${calib_dir#export_engine/}"
                fi
                # Remove trailing slash to avoid double slashes
                calib_dir="${calib_dir%/}"
                converted_args+=("--calib-data" "$calib_dir")
                i=$((i+1))
                ;;
            --calib-num)
                converted_args+=("--calib-limit" "${engine_args[$((i+1))]}")
                i=$((i+1))
                ;;
            --calib-list)
                converted_args+=("--calib-list" "${engine_args[$((i+1))]}")
                i=$((i+1))
                ;;
            --calib-cache)
                # C++ version doesn't support calib-cache parameter
                print_warning "calib-cache parameter not supported in C++ version, skipping"
                i=$((i+1))
                ;;
            *)
                # Pass through other arguments
                converted_args+=("${engine_args[$i]}")
                ;;
        esac
        i=$((i+1))
    done
    
    cmd+=("${converted_args[@]}")
    
    print_info "Executing command: ${cmd[*]}"
    
    # Execute the command
    local result=0
    if "${cmd[@]}"; then
        result=0
    else
        result=1
    fi
    
    # Return to original directory
    cd "$original_dir"
    
    if [ $result -eq 0 ]; then
        print_success "Engine conversion completed: $engine_file"
        return 0
    else
        print_error "Engine conversion failed!"
        return 1
    fi
}

# Main function
main() {
    local pt_file=""
    local engine_output=""
    local onnx_output=""
    local keep_onnx=true
    local onnx_only=false
    local check_env_flag=false
    local verbose=false
    local build_flag=false
    local clean_flag=false
    local rebuild_flag=false
    
    # Arguments for ONNX export
    local onnx_args=()
    
    # Arguments for Engine export
    local engine_args=()
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            --check-env)
                check_env_flag=true
                shift
                ;;
            -i|--input)
                pt_file="$2"
                shift 2
                ;;
            -o|--output)
                engine_output="$2"
                shift 2
                ;;
            --onnx-output)
                onnx_output="$2"
                shift 2
                ;;
            --keep-onnx)
                keep_onnx=true
                shift
                ;;
            --onnx-only)
                onnx_only=true
                shift
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            --build)
                build_flag=true
                shift
                ;;
            --clean)
                clean_flag=true
                shift
                ;;
            --rebuild)
                rebuild_flag=true
                shift
                ;;
            # ONNX export options
            -s|--static)
                onnx_args+=("--static")
                shift
                ;;
            -d|--dynamic)
                onnx_args+=("--dynamic")
                shift
                ;;
            --imgsz)
                onnx_args+=("--imgsz" "$2")
                shift 2
                ;;
            -b|--batch-size)
                onnx_args+=("--batch-size" "$2")
                shift 2
                ;;
            --opset)
                onnx_args+=("--opset" "$2")
                shift 2
                ;;
            --simplify)
                onnx_args+=("--simplify")
                shift
                ;;
            --no-simplify)
                onnx_args+=("--no-simplify")
                shift
                ;;
            --device)
                onnx_args+=("--device" "$2")
                shift 2
                ;;
            # Engine export options
            --precision)
                engine_args+=("--precision" "$2")
                shift 2
                ;;
            --workspace)
                engine_args+=("--workspace" "$2")
                shift 2
                ;;
            --calib-list)
                engine_args+=("--calib-list" "$2")
                shift 2
                ;;
            --calib-dir)
                engine_args+=("--calib-dir" "$2")
                shift 2
                ;;
            --calib-num)
                engine_args+=("--calib-num" "$2")
                shift 2
                ;;
            --calib-cache)
                engine_args+=("--calib-cache" "$2")
                shift 2
                ;;
            *)
                print_error "Unknown parameter: $1"
                echo "Use --help to view help information"
                exit 1
                ;;
        esac
    done
    
    # Handle environment check
    if [ "$check_env_flag" = true ]; then
        check_environment
        exit $?
    fi
    
    # Handle build operations
    if [ "$clean_flag" = true ]; then
        print_step "Cleaning build directory..."
        if [ -d "$SCRIPT_DIR/export_engine/build" ]; then
            rm -rf "$SCRIPT_DIR/export_engine/build"
            print_success "Build directory cleaned"
        else
            print_info "Build directory does not exist, nothing to clean"
        fi
        if [ "$build_flag" = false ] && [ "$rebuild_flag" = false ]; then
            exit 0
        fi
    fi
    
    if [ "$rebuild_flag" = true ]; then
        clean_flag=true
        build_flag=true
    fi
    
    if [ "$build_flag" = true ]; then
        print_step "Building C++ project..."
        cd "$SCRIPT_DIR/export_engine"
        if [ -f "./build.sh" ]; then
            ./build.sh
        else
            print_error "Build script not found: $SCRIPT_DIR/export_engine/build.sh"
            exit 1
        fi
        cd "$SCRIPT_DIR"
        print_success "C++ project build completed"
    fi
    
    # Check required parameters
    if [ -z "$pt_file" ]; then
        print_error "Missing required parameter -i or --input"
        echo ""
        show_help
        exit 1
    fi
    
    # Validate PT file
    if ! validate_pt_file "$pt_file"; then
        exit 1
    fi
    
    # Generate default output paths if not specified
    local model_dir
    model_dir="$(dirname "$pt_file")"
    local base_name
    base_name="$(basename "$pt_file")"
    base_name="${base_name%.*}"
    
    if [ -z "$onnx_output" ]; then
        onnx_output="$model_dir/${base_name}.onnx"
        print_info "ONNX output path not specified, automatically set to: $onnx_output"
    fi
    
    if [ -z "$engine_output" ] && [ "$onnx_only" = false ]; then
        # Determine suffix based on precision
        local suffix=""
        local precision="fp32"  # default
        
        # Extract precision from engine_args
        local i=0
        while [ $i -lt ${#engine_args[@]} ]; do
            if [ "${engine_args[$i]}" = "--precision" ] && [ $((i+1)) -lt ${#engine_args[@]} ]; then
                precision="${engine_args[$((i+1))]}"
                break
            fi
            i=$((i+1))
        done
        
        if [ "$precision" != "fp32" ]; then
            suffix="_$precision"
        fi
        engine_output="$model_dir/${base_name}${suffix}.engine"
        print_info "Engine output path not specified, automatically set to: $engine_output"
    fi
    
    # Print configuration summary
    print_separator
    print_info "Conversion configuration summary:"
    print_info "  Input PT model: $pt_file"
    print_info "  Intermediate ONNX file: $onnx_output"
    if [ "$onnx_only" = false ]; then
        print_info "  Output Engine file: $engine_output"
    fi
    print_info "  Keep ONNX file: $keep_onnx"
    print_info "  ONNX only export: $onnx_only"
    print_separator
    
    # Step 1: Convert PT to ONNX
    if ! convert_pt_to_onnx "$pt_file" "$onnx_output" "${onnx_args[@]}"; then
        exit 1
    fi
    
    # Check if ONNX file was created
    if [ ! -f "$onnx_output" ]; then
        print_error "ONNX file was not generated: $onnx_output"
        exit 1
    fi
    
    # If only ONNX export is requested, stop here
    if [ "$onnx_only" = true ]; then
        print_separator
        print_success "Conversion completed! ONNX model saved to: $onnx_output"
        print_separator
        exit 0
    fi
    
    # Step 2: Convert ONNX to Engine
    if ! convert_onnx_to_engine "$onnx_output" "$engine_output" "${engine_args[@]}"; then
        exit 1
    fi
    
    # Final success message
    print_separator
    print_success "All conversions completed!"
    print_info "  Input PT model: $pt_file"
    print_info "  Intermediate ONNX file: $onnx_output"
    print_info "  Output Engine file: $engine_output"
    print_separator
    
    return 0
}

# Script entry point
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
